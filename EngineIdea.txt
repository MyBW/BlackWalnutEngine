#在unreal中 上层的RenderTarge并不是一个包含GPU资源的一个类别（也就是说并不是使用glGenFrameBuffer产生的）更多是一个概念上的东西。
这样的好处是可以分配很多的RenderTarger  当要使用它们的时候可以将该RenderTarget“绑定”到真正的RenderTarget上

#Static State 这个技巧非常强大 首先将状态分组 通过使用模板来将这些状态组缓存起来 然后每次切换状态的之前进行判定 减少了生成状态以及切换状态的开销 是一种以时间换空间的策略
因为使用的是模板类来实现各种状态的  着表示在设置状态的时候  必须是显示设置（使用字面常量 而不是变量 设置） 因此 一些数值不适合使用模板类来表示  比如视口的大小 这些一般都是
变量 使用模板并不合适

#渲染引擎接口抽象可以遵循一个原则：根据渲染队列的划分依据来组织接口  例如 一般都是将使用相同纹理材质的作为一组渲染队列 那么可以将纹理也看成是一组数据 就可以提供一个接口


#一直在纠结这个TextureUnite类和Texture类只见的关系是什么  因为存放的数据成员都一样 所以总觉得两个其实是一样的  但是如果我们将RenderSystem看成是对底层渲染API的抽象 那么底层
在使用Texture的时候并不关心一些逻辑信息  其实TextureUnit就是用来保存这些逻辑信息的 比如PassParent等等 这样在实现对底层API封装的时候 就可以不用关心逻辑信息 这样的拆分更合理
一些

#发现一个智能指针的问题  如果一个指针可以cast到两种类型 且两种类型都是智能指针 那么当两种智能指针分别计数引用的时候 其中一个引用计数判定为0 时 就将该指针销毁 但是另一个还在使用
一种比较笨拙的解决方法是 在两种指针指针中重载相互转化赋值操作符 还没有想到其他办法